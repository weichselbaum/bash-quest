<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>v86 Terminal</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      width: 100%;
      height: 100%;
      background: #000;
      overflow: hidden;
    }
    #screen {
      width: 100%;
      height: 100%;
      background: #000;
      overflow: auto;
    }
    #screen canvas {
      display: block;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }
    #screen > div {
      white-space: pre;
      font: 14px monospace;
      line-height: 16px;
      padding: 4px;
    }
    #loading {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: #7ee787;
      font-family: monospace;
      text-align: center;
      z-index: 10;
      background: rgba(0, 0, 0, 0.7);
      padding: 8px 16px;
      border-radius: 6px;
    }
    #ready-hint {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: #8b949e;
      font-family: monospace;
      text-align: center;
      z-index: 10;
      background: rgba(0, 0, 0, 0.7);
      padding: 8px 16px;
      border-radius: 6px;
      font-size: 0.85rem;
    }
    .blinking-cursor {
      animation: blink 1s step-end infinite;
    }
    @keyframes blink {
      50% { opacity: 0; }
    }
  </style>
</head>
<body>
  <div id="screen">
    <!-- v86 expects a canvas and div inside the container -->
    <canvas></canvas>
    <div></div>
  </div>
  <div id="loading">
    <p id="status">Loading v86...</p>
  </div>
  <div id="ready-hint" style="display: none;">
    Type commands directly | Use # to ask questions (e.g. # what is ls?)
  </div>

  <script src="libv86.js"></script>
  <script>
    const screen = document.getElementById('screen');
    const loading = document.getElementById('loading');
    const status = document.getElementById('status');
    const readyHint = document.getElementById('ready-hint');
    let bootComplete = false;

    function init() {
      status.textContent = 'Initializing emulator...';

      const V86Constructor = window.V86Starter || window.V86;
      if (!V86Constructor) {
        status.textContent = 'Error: V86 not loaded';
        console.error('V86 not available');
        return;
      }

      console.log('V86 constructor found, creating emulator...');
      status.textContent = 'Booting Linux...';

      try {
        const emulator = new V86Constructor({
          wasm_path: 'v86.wasm',
          memory_size: 32 * 1024 * 1024,
          vga_memory_size: 2 * 1024 * 1024,
          screen_container: screen,
          bios: { url: 'seabios.bin' },
          vga_bios: { url: 'vgabios.bin' },
          cdrom: { url: 'linux.iso' },
          autostart: true,
          disable_speaker: true,
        });

        window.emulator = emulator;
        console.log('Emulator created successfully');

        emulator.add_listener('emulator-ready', function() {
          loading.style.display = 'none';
          console.log('Emulator ready');
          if (window.parent !== window) {
            window.parent.postMessage({ type: 'v86-ready' }, '*');
          }
        });

        emulator.add_listener('emulator-started', function() {
          console.log('Emulator started');
          status.textContent = 'Linux booting...';
        });

        // Serial output for command capture
        let serialBuffer = '';
        emulator.add_listener('serial0-output-byte', function(byte) {
          serialBuffer += String.fromCharCode(byte);
          if (serialBuffer.length > 2000) {
            serialBuffer = serialBuffer.slice(-1500);
          }
          // Detect shell prompt to know boot is complete
          if (!bootComplete && (serialBuffer.includes('/root%') || serialBuffer.includes('# ') || serialBuffer.includes('$ '))) {
            bootComplete = true;
            loading.style.display = 'none';
            // Auto-focus the terminal so user can type immediately
            screen.focus();
            window.focus();
            // Show hint after 3 seconds delay, keep for 10 seconds
            setTimeout(function() {
              readyHint.style.display = 'block';
              setTimeout(function() {
                readyHint.style.display = 'none';
              }, 10000);
            }, 3000);
          }
        });

        // Track keyboard input for direct terminal typing
        let currentLine = '';
        let lastScreenSnapshot = '';

        // Key repeat rate limiting (prevents insane repeat speeds)
        const keyRepeatDelay = 150; // ms between repeated keys
        const lastKeyTime = {};

        function shouldAllowKey(key, isRepeat) {
          if (!isRepeat) {
            lastKeyTime[key] = Date.now();
            return true;
          }
          const now = Date.now();
          const lastTime = lastKeyTime[key] || 0;
          if (now - lastTime >= keyRepeatDelay) {
            lastKeyTime[key] = now;
            return true;
          }
          return false;
        }

        // Intercept key events to throttle repeats (capture phase runs before v86)
        screen.addEventListener('keydown', function(e) {
          if (e.repeat && !shouldAllowKey(e.key, true)) {
            e.stopPropagation();
            e.preventDefault();
          }
        }, true); // capture phase

        // Get screen text - try multiple methods
        function getScreenText() {
          // Method 1: screen_adapter.get_text()
          try {
            if (emulator.screen_adapter && emulator.screen_adapter.get_text) {
              const text = emulator.screen_adapter.get_text();
              if (text && text.trim()) {
                console.log('Got screen text:', text.slice(0, 100));
                return text;
              }
            }
          } catch (err) {
            console.log('screen_adapter.get_text error:', err);
          }

          // Method 2: get_text_screen() returns array of rows
          try {
            if (emulator.screen_adapter && emulator.screen_adapter.get_text_screen) {
              const rows = emulator.screen_adapter.get_text_screen();
              if (rows && rows.length) {
                const text = rows.join('\n');
                console.log('Got text_screen:', text.slice(0, 100));
                return text;
              }
            }
          } catch (err) {
            console.log('get_text_screen error:', err);
          }

          // Method 3: Fall back to serial buffer
          console.log('Using serial buffer, length:', serialBuffer.length);
          return serialBuffer;
        }

        // Get relevant output - find command and its output
        function getRelevantOutput(command) {
          const text = getScreenText();
          if (!text) return serialBuffer.slice(-500);

          const lines = text.split('\n');

          // Find the LAST occurrence of the command (most recent)
          // Look backwards through lines to find it
          let commandLineIndex = -1;
          for (let i = lines.length - 1; i >= 0; i--) {
            const line = lines[i].trim();
            // Match prompt + command (e.g., "/root% ls" or "tests% cd foo")
            if (command && line.includes('%') && line.includes(command)) {
              commandLineIndex = i;
              break;
            }
          }

          if (commandLineIndex >= 0) {
            // Collect from command line to next prompt or end
            let outputLines = [];
            for (let i = commandLineIndex; i < lines.length; i++) {
              const line = lines[i].trim();
              if (!line) continue;
              outputLines.push(line);
              // Stop at next prompt (after collecting at least 2 lines)
              if (outputLines.length > 1 && line.endsWith('%')) {
                break;
              }
            }
            return outputLines.join('\n');
          }

          // Fallback: return last few non-boot lines
          const cleanLines = lines.filter(l => {
            const t = l.trim();
            return t && !t.startsWith('[') && !t.includes('RAMDISK') && !t.includes('VFS:');
          });
          return cleanLines.slice(-5).join('\n');
        }

        // Extract the actual command from the last prompt line on screen
        // This captures TAB-completed commands properly
        function getLastCommand() {
          const text = getScreenText();
          if (!text) return null;

          const lines = text.split('\n');
          // Find the most recent prompt line (ends with %)
          // The command is everything after the % on that line
          for (let i = lines.length - 1; i >= 0; i--) {
            const line = lines[i].trim();
            const promptIdx = line.lastIndexOf('%');
            if (promptIdx >= 0 && promptIdx < line.length - 1) {
              const cmd = line.slice(promptIdx + 1).trim();
              if (cmd) {
                console.log('Extracted command from screen:', cmd);
                return cmd;
              }
            }
          }
          return null;
        }

        document.addEventListener('keydown', function(e) {
          // Hide hint on any keypress
          if (readyHint.style.display !== 'none') {
            readyHint.style.display = 'none';
          }

          if (e.key === 'Enter') {
            if (currentLine.trim()) {
              const typedCmd = currentLine.trim();

              // Check if it's a comment (question to AI)
              if (typedCmd.startsWith('#')) {
                const question = typedCmd.slice(1).trim();
                console.log('Comment/question:', question);

                // Send as question, not command
                window.parent.postMessage({
                  type: 'user-question',
                  question: question
                }, '*');

                // Don't wait for output - comments produce no output
                currentLine = '';
                return;
              }

              console.log('Typed command:', typedCmd);

              // Wait for command to execute, then get output
              // Trust keyboard input as primary - only use screen if it shows MORE
              // (e.g. TAB completion expanded the command)
              setTimeout(function() {
                const screenCmd = getLastCommand();

                // Decide which command to use:
                // - If screen command contains typed command (TAB completion), use screen
                // - If screen command is shorter/different, trust keyboard (screen glitch)
                // - Default to typed command
                let cmd = typedCmd;
                if (screenCmd) {
                  // Screen has TAB-completed version if it's longer and starts similarly
                  const screenLonger = screenCmd.length > typedCmd.length;
                  const screenStartsSimilar = screenCmd.toLowerCase().startsWith(typedCmd.slice(0, 2).toLowerCase());
                  if (screenLonger && screenStartsSimilar) {
                    console.log('Using TAB-completed screen command:', screenCmd);
                    cmd = screenCmd;
                  } else {
                    console.log('Screen cmd ignored (shorter/different):', screenCmd, 'using typed:', typedCmd);
                  }
                }

                const output = getRelevantOutput(cmd);
                console.log('Sending command:', cmd, 'output:', output?.slice(0, 100));

                window.parent.postMessage({
                  type: 'command-output',
                  command: cmd,
                  output: output,
                  source: 'direct'
                }, '*');
              }, 1500);
            }
            currentLine = '';
          } else if (e.key === 'Backspace') {
            currentLine = currentLine.slice(0, -1);
          } else if (e.key.length === 1 && !e.ctrlKey && !e.altKey && !e.metaKey) {
            currentLine += e.key;
          }
        });

        // Listen for commands from parent
        window.addEventListener('message', function(e) {
          if (e.data && e.data.type === 'send-command') {
            const cmd = e.data.command;
            console.log('Received command from parent:', cmd);

            for (let i = 0; i < cmd.length; i++) {
              emulator.keyboard_send_text(cmd[i]);
            }
            emulator.keyboard_send_scancodes([0x1C, 0x9C]);

            setTimeout(function() {
              const output = getRelevantOutput(cmd);
              console.log('Sending output to parent:', output);

              window.parent.postMessage({
                type: 'command-output',
                command: cmd,
                output: output
              }, '*');
            }, 1500);
          }

          // Mission setup - inject shell commands to pre-populate environment
          if (e.data && e.data.type === 'setup-mission') {
            const script = e.data.script;
            const missionId = e.data.missionId;
            console.log('Setting up mission environment:', missionId);

            // Split script into lines and filter empties
            const lines = script.split('\n').filter(function(l) {
              return l.trim().length > 0;
            });

            let lineIndex = 0;

            function sendNextLine() {
              if (lineIndex >= lines.length) {
                console.log('Mission setup complete');
                window.parent.postMessage({
                  type: 'mission-ready',
                  missionId: missionId
                }, '*');
                return;
              }

              const line = lines[lineIndex++];
              console.log('Setup line:', line);

              // Send each character
              for (let i = 0; i < line.length; i++) {
                emulator.keyboard_send_text(line[i]);
              }
              // Send Enter
              emulator.keyboard_send_scancodes([0x1C, 0x9C]);

              // Wait for command to execute before next
              setTimeout(sendNextLine, 400);
            }

            // Start sending after a brief delay
            setTimeout(sendNextLine, 500);
          }
        });

        // Fallback hide loading
        setTimeout(function() {
          loading.style.display = 'none';
        }, 20000);

      } catch (e) {
        status.textContent = 'Error: ' + e.message;
        console.error('v86 error:', e);
      }
    }

    // Start when ready
    if (document.readyState === 'complete') {
      init();
    } else {
      window.addEventListener('load', init);
    }
  </script>
</body>
</html>
